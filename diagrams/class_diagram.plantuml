@startuml

interface "Action" {
  done()
  start()
  update()
}

class "Angle"

abstract class "AutoModeBase" {
  mUpdateRate : double
  mActive : boolean
  mIsInterrupted : boolean
  done()
  interrupt()
  resume()
  run()
  runAction(Action)
  stop()
  waitForDriverConfirm()
}

class "AutoModeEndedException"

class "AutoModeExecutor" {
  mAutoMode : AutoModeBase
  mThread : Thread
  interrupt()
  reset()
  resume()
  start()
  stop()
}

class "AutoModeSelector" {
  mCachedDesiredMode : DesiredMode
  mCachedStartingPosition : StartingPosition
  mModeChooser : SendableChooser<DesiredMode>
  mStartPositionChooser : SendableChooser<StartingPosition>
  mAutoMode : Optional<AutoModeBase>
  updateModeCreator()
}

class "ButtonPad"

class "CoDriver"

class "Constants"

class "ControlBindings"

class "ControlBoard" {
  joy : Joystick
  wheel : Joystick
  buttonPad : Joystick
  cojoy : Joystick
  overrideSetpoint : double
  climb() : boolean
  climbArms() : boolean
  climbArmsPressed() : boolean
  climbArmsReleased() : boolean
  climbPressed() : boolean
  climbReleased() : boolean
  colorWheelActuate() : boolean
  colorWheelRoller() : boolean
  colorWheelRollerReleased() : boolean
  feederActuatePressed() : boolean
  feederActuateReleased() : boolean
  panic() : boolean
  quickTurn() : boolean
  reverseFeeder() : boolean
  reverseFeederPressed() : boolean
  reverseFeederReleased() : boolean
  rollers() : boolean
  rollersPressed() : boolean
  rollersReleased() : boolean
  shoot() : boolean
  shootPressed() : boolean
  shootReleased() : boolean
  trackClockwise() : boolean
  trackCounterClockwise() : boolean
  unjam() : boolean
  unjamReleased() : boolean
  visionTrack() : boolean
  visionTrackPressed() : boolean
}

enum "ControlState" {
  OPEN_LOOP
  MOTION_MAGIC
  POSITION_PID
  MOTION_PROFILING
}

class "Coordinate" {
  x : double
  y : double
  add(Coordinate) : Coordinate
  addC(Coordinate) : Coordinate
  changeBasis(Coordinate, Coordinate) : Coordinate
  changeBasisC(Coordinate, Coordinate) : Coordinate
  copy() : Coordinate
  display() : String
  display(String) : String
  heading() : Heading
  inverseC() : Coordinate
  mult(double, double) : Coordinate
  mult(double) : Coordinate
  multC(double, double) : Coordinate
  multC(double) : Coordinate
  normalize() : Coordinate
  normalizeC() : Coordinate
  outputData() : String
  reverseC() : Coordinate
  rotateByC(Heading) : Coordinate
  setMagnitude(double) : Coordinate
  setXMaintainMag(double, boolean)
  setXY(double, double)
  setYMaintainMag(double, boolean)
  sub(Coordinate) : Coordinate
  subC(Coordinate) : Coordinate
}

class "Derivative" {
  pVal : double
  val : double
  output : double
  pTime : double
  Calculate(double, double) : double
  reset(double, double)
}

class "DoNothingMode"

class "Drive" {
  mCSVWriter : ReflectingCSVWriter<PeriodicIO>
  mLeftMaster : LazySparkMax
  mRightMaster : LazySparkMax
  mLeftSlave : LazySparkMax
  mRightSlave : LazySparkMax
  mLeftEncoder : TalonSRX
  mRightEncoder : TalonSRX
  mPigeonTalon : TalonSRX
  mPigeon : PigeonIMU
  mGyroOffset : Rotation2d
  mPathFollower : PathFollower
  mCurrentPath : Path
  mDriveControlState : DriveControlState
  mDriveCurrentLimitState : DriveCurrentLimitState
  mIsBrakeMode : boolean
  mLastDriveCurrentSwitchTime : double
  mPeriodicIO : PeriodicIO
  autoSteer(double, AimingParameters)
  checkSystem() : boolean
  forceDoneWithPath()
  hasPassedMarker(String) : boolean
  outputTelemetry()
  readPeriodicInputs()
  registerEnabledLoops(ILooper)
  resetEncoders()
  setCheesyishDrive(double, double, boolean)
  setVelocity(DriveSignal, DriveSignal)
  setWantDrivePath(Path, boolean)
  startLogging()
  stop()
  stopLogging()
  writePeriodicOutputs()
  zeroSensors()
}

enum "DriveControlState" {
  OPEN_LOOP
  PATH_FOLLOWING
}

enum "DriveCurrentLimitState" {
  UNTHROTTLED
  THROTTLED
}

class "DrivePath"

class "Driver"

class "Heading" {
  inverseC() : Coordinate
  inverseC() : Heading
  perpendicularCCw() : Heading
  perpendicularCCwC() : Heading
  perpendicularCw() : Heading
  perpendicularCwC() : Heading
}

abstract class "IControlBoard" {
  climb() : boolean
  climbArms() : boolean
  climbArmsPressed() : boolean
  climbArmsReleased() : boolean
  climbPressed() : boolean
  climbReleased() : boolean
  colorWheelActuate() : boolean
  colorWheelRoller() : boolean
  colorWheelRollerReleased() : boolean
  feederActuatePressed() : boolean
  feederActuateReleased() : boolean
  panic() : boolean
  quickTurn() : boolean
  reverseFeeder() : boolean
  reverseFeederPressed() : boolean
  reverseFeederReleased() : boolean
  rollers() : boolean
  rollersPressed() : boolean
  rollersReleased() : boolean
  shoot() : boolean
  shootPressed() : boolean
  shootReleased() : boolean
  trackClockwise() : boolean
  trackCounterClockwise() : boolean
  unjam() : boolean
  unjamReleased() : boolean
  visionTrack() : boolean
  visionTrackPressed() : boolean
}

interface "ILooper" {
  register(Loop)
}

class "Jevois" {
  checkSystem() : boolean
  outputTelemetry()
  stop()
}

class "Kinematics"

class "Length"

interface "Loop" {
  onLoop(double)
  onStart(double)
  onStop(double)
}

class "Looper" {
  kPeriod : double
  mRunning : boolean
  mNotifier : Notifier
  mLoops : List<Loop>
  mTaskRunningLock : Object
  mTimestamp : double
  mDT : double
  runnable_ : CrashTrackingRunnable
  outputToSmartDashboard()
  register(Loop)
  start()
  stop()
}

class "LowPassFilter" {
  oldValue : double
  a : double
  update(double) : double
}

class "Main"

class "Mass"

class "NoopAction" {
  done()
  start()
  update()
}

class "ParallelAction" {
  mActions : ArrayList<Action>
  done()
  start()
  update()
}

class "PathBuilder"

interface "PathContainer" {
  buildPath() : Path
}

class "PeriodicIO" {
  timestamp : double
  left_voltage : double
  right_voltage : double
  left_position_ticks : int
  right_position_ticks : int
  left_distance : double
  right_distance : double
  left_velocity_ticks_per_100ms : int
  right_velocity_ticks_per_100ms : int
  gyro_heading : Rotation2d
  error : Pose2d
  left_demand : double
  right_demand : double
  left_accel : double
  right_accel : double
  left_feedforward : double
  right_feedforward : double
}

class "Pos2D" {
  position : Coordinate
  heading : Heading
  copy() : Pos2D
  inverseC() : Pos2D
  multC(double) : Coordinate
  outputData() : String
  outputData(String) : String
  setHeading(Heading) : Pos2D
  setHeading(double, double) : Pos2D
  setPos(double, double)
  transformByC(Pos2D) : Pos2D
}

class "Robot" {
  mEnabledLooper : Looper
  mDisabledLooper : Looper
  mControlBoard : IControlBoard
  mSubsystemManager : SubsystemManager
  mRobotState : RobotState
  mDrive : Drive
  mHasBeenEnabled : boolean
  mOffsetOverride : double
  autonomousInit()
  autonomousPeriodic()
  disabledInit()
  disabledPeriodic()
  robotInit()
  robotPeriodic()
  teleopInit()
  teleopPeriodic()
  telopControls()
  testInit()
  testPeriodic()
}

class "RobotState" {
  field_to_vehicle_ : InterpolatingTreeMap<InterpolatingDouble, Pose2d>
  vehicle_to_turret_ : InterpolatingTreeMap<InterpolatingDouble, Rotation2d>
  vehicle_velocity_predicted_ : Twist2d
  vehicle_velocity_measured_ : Twist2d
  vehicle_velocity_measured_filtered_ : MovingAverageTwist2d
  distance_driven_ : double
  kPossibleTargetNormals : double[]
  addFieldToVehicleObservation(double, Pose2d)
  addObservations(double, Twist2d, Twist2d, Twist2d)
  addVehicleToTurretObservation(double, Rotation2d)
  getFieldToTurret(double) : Pose2d
  getFieldToVehicle(double) : Pose2d
  getPredictedFieldToVehicle(double) : Pose2d
  getVehicleToTurret(double) : Rotation2d
  outputToSmartDashboard()
  reset(double, Pose2d)
  reset()
  reset(double, Pose2d, Rotation2d)
  resetDistanceDriven()
}

abstract class "RunOnceAction" {
  done()
  runOnce()
  start()
  update()
}

class "SerialReader" {
  comPort : SerialPort
  buffer : BufferedReader
  close()
  readLine() : String
  readUntilChar(char) : String
  sendMessage(String)
}

class "ServoMotorSubsystem" {
  mConstants : ServoMotorSubsystemConstants
  mMaster : TalonSRX
  mSlaves : TalonSRX[]
  mForwardSoftLimitTicks : int
  mReverseSoftLimitTicks : int
  mPeriodicIO : PeriodicIO
  mControlState : ControlState
  mCSVWriter : ReflectingCSVWriter<PeriodicIO>
  mHasBeenZeroed : boolean
  mFaults : StickyFaults
  mSetpointGenerator : SetpointGenerator
  mMotionProfileConstraints : MotionProfileConstraints
  atHomingLocation() : boolean
  checkSystem() : boolean
  estimateSensorPositionFromAbsolute() : int
  getPredictedPositionUnits(double) : double
  handleMasterReset(boolean)
  hasBeenZeroed() : boolean
  hasFinishedTrajectory() : boolean
  outputTelemetry()
  readPeriodicInputs()
  registerEnabledLoops(ILooper)
  resetIfAtLimit()
  setGoalMotionProfiling(MotionProfileGoal, double)
  setSetpointMotionMagic(double, double)
  setSetpointPositionPID(double, double)
  stop()
  writePeriodicOutputs()
  zeroSensors()
}

class "ServoMotorSubsystemConstants" {
  kName : String
  kMasterConstants : TalonSRXConstants
  kSlaveConstants : TalonSRXConstants[]
  kHomePosition : double
  kTicksPerUnitDistance : double
  kKp : double
  kKi : double
  kKd : double
  kKf : double
  kKa : double
  kMaxIntegralAccumulator : double
  kIZone : int
  kDeadband : int
  kPositionKp : double
  kPositionKi : double
  kPositionKd : double
  kPositionKf : double
  kPositionMaxIntegralAccumulator : double
  kPositionIZone : int
  kPositionDeadband : int
  kCruiseVelocity : int
  kAcceleration : int
  kRampRate : double
  kContinuousCurrentLimit : int
  kPeakCurrentLimit : int
  kPeakCurrentDuration : int
  kMaxVoltage : double
  kMaxUnitsLimit : double
  kMinUnitsLimit : double
  kStatusFrame8UpdateRate : int
  kRecoverPositionOnReset : boolean
}

abstract class "Subsystem" {
  checkSystem() : boolean
  outputTelemetry()
  readPeriodicInputs()
  registerEnabledLoops(ILooper)
  stop()
  writePeriodicOutputs()
  writeToLog()
  zeroSensors()
}

class "SubsystemManager" {
  mAllSubsystems : List<Subsystem>
  mLoops : List<Loop>
  checkSubsystems() : boolean
  outputToSmartDashboard()
  register(Loop)
  registerDisabledLoops(Looper)
  registerEnabledLoops(Looper)
  setSubsystems(Subsystem[])
  stop()
}

class "TalonSRXConstants" {
  id : int
  invert_motor : boolean
  invert_sensor_phase : boolean
}

class "TestMode"

class "Time"

class "Toggle" {
  toggle : boolean
  pInput : boolean
  toggleVar(boolean) : boolean
}

class "TrapezoidalMp" {
  maxAccel : double
  maxVel : double
  setpoint : double
  startSetpoint : double
  endAccel : double
  endConstSpeed : double
  endDeccel : double
  setpointSign : int
  mConstraints : constraints
  initial : vector
  currentPhase : phase
  Calculate(double) : double[]
  updateConstraints(double, constraints)
}

class "Units"

class "Util"

class "Velocity"

class "Vision" {
  pigeon : PigeonIMU
  angleDiff : double
  visionAngle : double
  currentAngle : double
  visionServer : udpServer
  map : Map<Double, double[]>
  data : double[][]
  teleopOffsets : double[][]
  angleToMatrix(double) : double[][]
  cameraTracking() : boolean
  dataLookUp(double) : double[]
  display()
  offsetAngle(double, double) : double
  offsetLookUp(double) : double
  robotVelocity(double, double) : double[]
  trackPoint(double[], double[]) : double
  translate(double[], double[][]) : double[]
}

class "WaitAction" {
  mTimeToWait : double
  mStartTime : double
  done()
  start()
  update()
}

class "WaitForPathMarkerAction" {
  mDrive : Drive
  mMarker : String
  done()
  start()
  update()
}

class "Waypoint" {
  position : Translation2d
  radius : double
  speed : double
  marker : String
}

class "constraints" {
  maxAccel : double
  maxVel : double
  setpoint : double
}

enum "phase" {
  accel
  constSpeed
  deccel
  done
}

class "udpServer" {
  udpSocket : DatagramSocket
  port : int
  data : double[]
  lock : Semaphore
  run()
}

abstract class "vector" {
  position : double
  velocity : double
  this$0 : TrapezoidalMp
}

"Action" <|-- "NoopAction"
"Action" "*" <-> "ParallelAction" : /mActions
"Action" <|-- "RunOnceAction"
"Action" <|-- "WaitAction"
"Action" <|-- "WaitForPathMarkerAction"
"AutoModeBase" --> "Action" : use
"AutoModeBase" <|-- "DoNothingMode"
"AutoModeBase" <|-- "TestMode"
"AutoModeExecutor" --> "AutoModeBase" : mAutoMode
"AutoModeSelector" --> "AutoModeBase" : mAutoMode
"Coordinate" --> "Heading" : use
"Coordinate" <-> "Heading"
"Drive" --> "DriveControlState" : mDriveControlState
"Drive" --> "DriveCurrentLimitState" : mDriveCurrentLimitState
"Drive" --> "ILooper" : use
"Drive" --> "PeriodicIO" : mCSVWriter/mPeriodicIO
"IControlBoard" <|-- "ControlBoard"
"ILooper" --> "Loop" : use
"ILooper" <|-- "Looper"
"ILooper" <|-- "SubsystemManager"
"Looper" --> "*" "Loop" : mLoops
"Pos2D" --> "Coordinate" : position
"Pos2D" --> "Heading" : heading
"Robot" --> "Drive" : mDrive
"Robot" --> "IControlBoard" : mControlBoard
"Robot" --> "Looper" : mEnabledLooper/mDisabledLooper
"Robot" --> "RobotState" : mRobotState
"Robot" --> "SubsystemManager" : mSubsystemManager
"ServoMotorSubsystemConstants" --> "TalonSRXConstants" : kMasterConstants
"ServoMotorSubsystem" --> "ControlState" : mControlState
"ServoMotorSubsystem" --> "ILooper" : use
"ServoMotorSubsystem" --> "PeriodicIO" : mPeriodicIO/mCSVWriter
"ServoMotorSubsystem" --> "ServoMotorSubsystemConstants" : mConstants
"Subsystem" <|-- "Drive"
"Subsystem" --> "ILooper" : use
"Subsystem" <|-- "Jevois"
"SubsystemManager" --> "*" "Loop" : mLoops
"SubsystemManager" --> "Looper" : use
"SubsystemManager" --> "*" "Subsystem" : mAllSubsystems
"Subsystem" <|-- "ServoMotorSubsystem"
"TrapezoidalMp" --> "constraints" : mConstraints
"TrapezoidalMp" --> "phase" : currentPhase
"TrapezoidalMp" <-> "vector" : initial/this$0
"Vision" --> "udpServer" : visionServer
"WaitForPathMarkerAction" --> "Drive" : mDrive

@enduml